import 'dart:convert';
import 'dart:io';
import 'package:flutter_test/flutter_test.dart';
import 'package:chalawa/chalawa.dart';

void main() {
  group('Node.js Compatibility Tests', () {
    late Map<String, dynamic> testData;

    setUpAll(() async {
      // Load test data generated by Node.js
      final file = File('../backend/compatibility-test-data.json');
      if (await file.exists()) {
        final jsonString = await file.readAsString();
        testData = jsonDecode(jsonString);
      } else {
        fail('compatibility-test-data.json not found. Run Node.js compatibility test first.');
      }
    });

    test('Should decrypt Node.js encrypted data', () {
      final nodeEncrypted = testData['basic']['encrypted'] as String;
      final password = testData['basic']['password'] as String;
      final expectedPlainText = testData['basic']['plainText'] as String;

      final decrypted = decrypt(DecryptionInput(
        encryptedText: nodeEncrypted,
        password: password,
      ));

      expect(decrypted, expectedPlainText);
    });

    test('Should compute same DH shared secret as Node.js', () {
      final alicePrivateKey = testData['diffieHellman']['alice']['privateKey'] as String;
      final bobPublicKey = testData['diffieHellman']['bob']['publicKey'] as String;
      final expectedSharedSecret = testData['diffieHellman']['sharedSecret'] as String;

      final computedSecret = computeSharedSecret(DHSharedSecretInput(
        privateKey: alicePrivateKey,
        otherPublicKey: bobPublicKey,
      ));

      expect(computedSecret, expectedSharedSecret);
    });

    test('Should decrypt Node.js DH encrypted data', () {
      final nodeEncrypted = testData['diffieHellman']['encrypted'] as String;
      final sharedSecret = testData['diffieHellman']['sharedSecret'] as String;
      final expectedPlainText = testData['diffieHellman']['plainText'] as String;

      final decrypted = dhDecrypt(DHDecryptionInput(
        encryptedText: nodeEncrypted,
        sharedSecret: sharedSecret,
      ));

      expect(decrypted, expectedPlainText);
    });

    test('Flutter encrypted data should be decryptable by same parameters', () {
      const plainText = 'Hello from Flutter!';
      const password = 'test-password-flutter';

      // Encrypt with Flutter
      final encrypted = encrypt(const EncryptionInput(
        plainText: plainText,
        password: password,
      ));

      // Decrypt with Flutter
      final decrypted = decrypt(DecryptionInput(
        encryptedText: encrypted,
        password: password,
      ));

      expect(decrypted, plainText);
      print('Flutter encryption format: $encrypted');
    });

    test('Cross-platform DH key exchange simulation', () {
      // Generate Flutter keys
      final flutterKeyPair = generateDHKeyPair();
      
      // Use Node.js keys from test data
      final nodeAlicePrivate = testData['diffieHellman']['alice']['privateKey'] as String;
      final nodeBobPublic = testData['diffieHellman']['bob']['publicKey'] as String;
      
      // Compute shared secret: Flutter private + Node.js public
      final flutterSecret1 = computeSharedSecret(DHSharedSecretInput(
        privateKey: flutterKeyPair.privateKey,
        otherPublicKey: nodeBobPublic,
      ));
      
      // Compute shared secret: Node.js private + Flutter public
      final flutterSecret2 = computeSharedSecret(DHSharedSecretInput(
        privateKey: nodeAlicePrivate,
        otherPublicKey: flutterKeyPair.publicKey,
      ));
      
      // These should be different (as expected) since we're using different key pairs
      expect(flutterSecret1.isNotEmpty, true);
      expect(flutterSecret2.isNotEmpty, true);
      
      print('Cross-platform DH test completed successfully');
    });
  });
}
